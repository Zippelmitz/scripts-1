#!/usr/bin/env perl

use strict;
use warnings;
use Cwd;
use File::Spec::Functions qw( splitdir catdir catfile );
use JSON;
use Getopt::Long;
use Data::Dump ();
use DateTime;

my %cfg;
my $ok = GetOptions(
  \%cfg,
  "help",
  "verbose+",
  "quiet",
  "dryrun|n"
);
usage() unless $ok;
usage() if $cfg{help};

$cfg{root} ||= find_project_root();
$cfg{verbose} ||= 0;
$cfg{quiet} ||= 0;

dispatch_command(\%cfg, @ARGV);


sub dispatch_command {
  my ($cfg, $cmd, @args) = @_;
  
  if (!defined($cmd)) {
    usage();
    return;
  }
  
  load_cfg($cfg);

  if ($cmd eq 'deploy') {
    deploy($cfg, @args);
  }
  else {
    usage("Command '$cmd' not understood");
  }
  
  return
}


##########
# Commands

sub deploy {
  my ($cfg, $env) = @_;
  my $pcfg = $cfg->{project};
  my $pname = $pcfg->{project}{name} || (find_project_root())[-1];

  usage('Deploy requires an environment as parameter.',
    'Valid values are: ' . join(', ', sort keys %{$pcfg->{environments}}))
    unless defined $env;

  ### Decide which environment to use
  my $ecfg = $pcfg->{environments}{$env};
  usage("Environment '$env' not found in rules.prj") unless $ecfg;
  debug("Using environment '$env'");

  ### Prepare base rsync command to run
  my $rsync = $pcfg->{commands}{rsync};
  $rsync = [split(/\s+/, $rsync)] if $rsync && !ref($rsync);
  $rsync ||= ['rsync', '-a'];

  ### Include excludes
  if (my $excl = $pcfg->{paths}{exclude}) {
    $excl = [ $excl ] unless ref($excl) eq 'ARRAY';
    push @$rsync, map { ('--exclude', $_) } @$excl;
  }
  
  ### Add common rsync options
  push @$rsync, '-v' if $cfg->{verbose} || $pcfg->{verbose};
  push @$rsync, '-n' if $cfg->{dryrun};
  push @$rsync, "$cfg->{root}/";

  ### Hosts to use
  my @hosts = @{$ecfg->{hosts} || []};
  push @hosts, $ecfg if $ecfg->{host};
  fatal("Environment '$env' missing 'host' or 'hosts' entry: $ecfg") unless @hosts;

  ### Check for proper branch
  if (my $branch_name = $ecfg->{branch}) {
    my $cur_branch = _current_branch_name();
    fatal("Current branch '$cur_branch' not the expected one '$branch_name")
      unless $cur_branch eq $branch_name;
  }

  ### Check for tags
  if ($ecfg->{tag}) {
    _tag_release($env);
  }

  ### Describe the current release
  END { unlink('.release') }
  system('git describe --always --tags > .release');
  system('pwd >> .release');

  ### rsync to each one
  foreach my $host (@hosts) {
    fatal("Env '$env' with missing 'host'") unless $host->{host};

    my @cmd = @$rsync;

    ### prepare the SSH transport settings
    push @cmd, '-e', 'ssh';
    $cmd[-1] .= " -l $host->{user}" if $host->{user};
    $cmd[-1] .= " -p $host->{port}" if $host->{port};

    push @cmd, join(':', $host->{host}, ($host->{path} || $ecfg->{path}));

    debug('Rsync command:', \@cmd);
    system(@cmd) unless $cfg{dryrun};
    
    if (exists $ecfg->{post_deploy}) {
      @cmd = ('ssh', $host->{host});
      push(@cmd, '-v') if $cfg->{verbose} || $pcfg->{verbose};
      push(@cmd, '-l', $host->{user}) if $host->{user};
      push(@cmd, '-p', $host->{port}) if $host->{port};
      push @cmd, "cd ".($host->{path} || $ecfg->{path})." && $ecfg->{post_deploy}";
      
      debug('Post deploy command:', \@cmd);
      system(@cmd) unless $cfg{dryrun};
    }
  }

  notify("Sucessfully deployed '$env' for project '$pname'", $pname, $env) unless $cfg{dryrun};
  return;
}

#######
# Usage

sub usage {
  my ($msg, @others) = @_;
  
  print STDERR <<EOU;
Usage: prj COMMAND ARGS

The current list of COMMANDs is:

    deploy    deploys current version to an environment

EOU

  print STDERR "ERROR: $msg\n" if $msg;
  foreach my $err (@others) {
    print ' => ', $err, "\n";
  }
  exit(1);
}


########
# Logger

sub debug {
  return if $cfg{quiet};
  return unless $cfg{verbose} > 1;
  
  return _log('DEBUG', @_);  
}

sub fatal {
  _log('FATAL', @_);  
  exit(1);
}

sub _log {
  my $tag = shift;
  my $msg = join(' ', map { ref($_)? Data::Dump::pp($_) : $_ } @_);
  
  foreach my $line (split(/\n\r?/, $msg)) {
    print STDERR "[$tag]: $line\n";
  }

  return;
}

#######
# Utils

sub load_cfg {
  my ($cfg) = @_;
  my $root = $cfg->{root};
  my $prj_cfg;
  
  if (open(my $fh, '<', catfile($root, 'rules.prj'))) {
    local $/;
    $prj_cfg = decode_json(<$fh>);
    close($fh);
  }
  else {
    die "Could not open 'rules.prj' file in $root: $!\n";
  }
  
  $cfg->{project} = $prj_cfg;
}

sub find_project_root {
	my $project_root;
	
	my @cwd = splitdir(getcwd());
	do {
		my $cwd = catdir(@cwd);
		
		if (-e catfile($cwd, 'rules.prj')) {
			$project_root = $cwd;
		}
		elsif ($cwd eq $ENV{HOME} || scalar(@cwd) == 1) {
			die "Could not find project root (was looking for rules.prj)\n";
		}
		else {
			pop @cwd;
		}
	} while (!$project_root);
	
	return @cwd if wantarray;
	return $project_root;
}

sub notify {
  my ($message, $proj, $env) = @_;

  eval { require WebService::Notifo };
  if (!$@) {
    my $n = WebService::Notifo->new;
    $n->send_notification( label => 'prj', title => "$proj ($env)", msg => $message);
  }
  elsif (my $gn = _has_cmd('growlnotify')) {
    system($gn, '-m', $message, 'prj deploy status');
  }

  return;
}

sub _has_cmd {
  my ($cmd) = @_;

  for my $path (split(/:/, $ENV{PATH})) {
    my $fn = catfile($path, $cmd);
    return $fn if -x $fn;
  }

  return;
}


############
# Operations

sub _tag_release {
  my ($env) = @_;
  
  my $now = DateTime->now;
  my $tag = join('-', 'release', $env, $now->ymd('').$now->hms(''));

  return system('git', 'tag', $tag);
}

sub _current_branch_name {
  my $name = `git symbolic-ref HEAD`;
  chomp $name;
  ($name) = $name =~ m{^refs/[^/]+/(.+)};
  return $name;
}
